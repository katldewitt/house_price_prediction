---
title: "Stat 420 Final Project Work"
author: "Avinash Tiwari - tiwari6"
date: ''
output:
  html_document: 
    theme: readable
    toc: yes  
  pdf_document: default
urlcolor: cyan
---

# Analysis Workbook
<<<<<<< Updated upstream
## Proposal
## Define Helper Functions
## EDA

=======
>>>>>>> Stashed changes
```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
options(scipen = 1, digits = 4, width = 80, fig.alin = "center")
```


```{r}
# set seed
set.seed(11)

# Load libraries 
library(ggplot2)
library(faraway)
```

<<<<<<< Updated upstream

```{r}
ca_housing_data = read.csv('../000_Data/california-housing-prices/housing.csv')
head(ca_housing_data)
View(ca_housing_data)
str(ca_housing_data)
```

```{r}
# Missing Values
which(is.na(ca_housing_data$longitude))
which(is.na(ca_housing_data$latitude))
which(is.na(ca_housing_data$housing_median_age))
which(is.na(ca_housing_data$total_rooms))
length(which(is.na(ca_housing_data$total_bedrooms)))
which(is.na(ca_housing_data$population))
which(is.na(ca_housing_data$households))
which(is.na(ca_housing_data$median_income))
which(is.na(ca_housing_data$median_house_value))
which(is.na(ca_housing_data$ocean_proximity))
```

```{r}
apply(is.na(ca_housing_data), 2, which)
apply(is.na(ca_housing_data), 2, sum)
```

```{r}
# delete rows with missing values - as only 207 rows have missing value for only one variable "total_bedrooms"
nrow(ca_housing_data)
cah_data = na.omit(ca_housing_data)
nrow(ca_housing_data) - nrow(cah_data)
```


```{r}
# range of variables 
range(cah_data$longitude)
range(cah_data$latitude)
range(cah_data$housing_median_age)
range(cah_data$total_rooms)
range(cah_data$total_bedrooms) #why? 
range(cah_data$population)
range(cah_data$households)
range(cah_data$median_income)
range(cah_data$median_house_value)
table(cah_data$ocean_proximity)
```

```{r}
apply(cah_data, 2, range)
```

```{r}
table(cah_data$ocean_proximity)
```

```{r}
# cast ocean_proximity as factor variable
cah_data$ocean_proximity = as.factor(cah_data$ocean_proximity)
```


```{r}
# separating numerical and categorical vars for EDA
cah_data_num = cah_data[ ,!sapply(cah_data, is.factor)]
cah_data_cat = cah_data[ ,sapply(cah_data, is.factor)]
```


```{r}
#histogram of numerical variables 
hist(cah_data_num$longitude)
hist(cah_data_num$latitude)
hist(cah_data_num$housing_median_age)
hist(cah_data_num$total_rooms)
hist(cah_data_num$total_bedrooms)
hist(cah_data_num$population)
hist(cah_data_num$households)
hist(cah_data_num$median_income)
hist(cah_data_num$median_house_value)
```


```{r}
table(cah_data_cat)
```


```{r}
# heatmap of numerical variable pairs 
library(faraway)
pairs(cah_data_num, col = "dodgerblue")
```
```{r}
# scatterplot with response 

ggplot(data = cah_data_num) + 
  geom_point(mapping = aes(x = longitude, y = median_house_value), col = "dodgerblue")

ggplot(data = cah_data_num) + 
  geom_point(mapping = aes(x = latitude, y = median_house_value), col = "dodgerblue")

ggplot(data = cah_data_num) + 
  geom_point(mapping = aes(x = housing_median_age, y = median_house_value), col = "dodgerblue")

ggplot(data = cah_data_num) + 
  geom_point(mapping = aes(x = total_rooms, y = median_house_value), col = "dodgerblue")

ggplot(data = cah_data_num) + 
  geom_point(mapping = aes(x = total_bedrooms, y = median_house_value), col = "dodgerblue")

ggplot(data = cah_data_num) + 
  geom_point(mapping = aes(x = population, y = median_house_value), col = "dodgerblue")

ggplot(data = cah_data_num) + 
  geom_point(mapping = aes(x = households, y = median_house_value), col = "dodgerblue")

ggplot(data = cah_data_num) + 
  geom_point(mapping = aes(x = median_income, y = median_house_value), col = "dodgerblue")

```
```{r}
# Outlier Detection 
mod_out = lm(median_house_value ~ ., data = cah_data_num)
hatvalues(mod_out)
which.max(hatvalues(mod_out)) 
cah_data_num[which.max(hatvalues(mod_out)),]
sum(hatvalues(mod_out) > 2 * mean(hatvalues(mod_out))) # 1330 observations 

which.max(cooks.distance(mod_out) > 4/cooks.distance(mod_out))  # 15213

max(cooks.distance(mod_out))
cah_data_num[15361,]
cah_data_num[15213,]

```

## Data cleaning

```{r}
cah_trn_idx  = sample(nrow(cah_data), size = trunc(0.80 * nrow(cah_data)))
cah_trn_data = cah_data[cah_trn_idx, ]
cah_tst_data = cah_data[-cah_trn_idx, ]
```

## Variable Creation
```{r}
cah_trn_data$ocean_proximity = as.factor(cah_trn_data$ocean_proximity)
cah_trn_data$pop_per_hh = cah_trn_data$population / cah_trn_data$households
cah_trn_data$rooms_per_hh = cah_trn_data$total_rooms / cah_trn_data$households
cah_trn_data$bedrooms_per_hh = cah_trn_data$total_bedrooms / cah_trn_data$households
```

## Model Building
```{r}
mod = lm(log(median_house_value) ~ . - (total_bedrooms + total_rooms + households + rooms_per_hh +  latitude + population), data = cah_trn_data)
summary(mod)
vif(mod)
mod_fix = lm(log(median_house_value) ~ . - (total_bedrooms + total_rooms + households + rooms_per_hh +  latitude + population), data = cah_trn, subset = cooks.distance(mod) <= 4 / length(cah_trn$median_house_value))
```

```{r}
mod_fix = lm(log(median_house_value) ~ . - (total_bedrooms + total_rooms + households + rooms_per_hh +  latitude + population), data = cah_trn_data, subset = cooks.distance(mod) <= 4 / length(cah_trn_data$median_house_value))
summary(mod_fix)
```



```{r}

library(lmtest)

=======
## Proposal
## Define Helper Functions
```{r}

## 1. FUNCTIONS TO CHECK / OPTIMIZE MODEL PERFORMANCE ##

# function to get RMSE 
get_RMSE = function(fitted_y, actual_y){
  n = length(fitted_y)                                      #length of data 
  rmse = sqrt((sum(((actual_y - fitted_y) ^ 2)) / n))
}

# function to get R-Square  
get_R_SQ = function(fitted_y, actual_y) {
  n = length(fitted_y)
  SST = sum((actual_y - mean(actual_y)) ^ 2)                #Sum of Square Total 
  SSReg = sum((fitted_y - mean(actual_y)) ^ 2)              #Sum of Square Regression 
  SSReg / SST                                               # Proportion of variance in the data explained by regression 
}

# function to get adjusted R-Square 
get_adj_r2 = function(model) {
  summary(model)$adj.r.squared
}

# function to get estimated SD for MLE = TRUE or MLE = FALSE 
get_sd_est = function(fitted_vals, actual_vals, mle = FALSE) {
  e     = actual_vals - fitted_vals
  n     = length(e)
  if (mle) {
    s2_e = (sum(e ^ 2)) / n
  } else {
    s2_e  = (sum(e ^ 2)) / (n - 2)
  }
  sqrt(s2_e)
}

# function to get number of parameters in a model 
get_num_params = function(model) {
  length(coef(model))
}

# function to get 'Leave-one-out-cross-validated-RMSE'
get_loocv_rmse = function(model) {
  sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}

# function to get confidence matrix for Logistic Regressopn Classification 
make_conf_mat = function(predicted, actual) {
  table(predicted = predicted, actual = actual)
}

# function to get sensitivity 
get_sens = function(conf_mat) {
  conf_mat[2, 2] / sum(conf_mat[, 2])
}

#function to get specificity
get_spec =  function(conf_mat) {
  conf_mat[1, 1] / sum(conf_mat[, 1])
}

# function to get observations with high leverage 
get_leverage = function(model){
  hatvalues(model) > 2 * mean(hatvalues(model))
}

# function to get outlier observations based on cooks-distance
get_outliers = function(model){
  cooks.distance(model) > 4 / length(cooks.distance(model))  
}

# function to get scatterplot of all variable pairs in a dataset (for only numerical variables)
get_pairs = function(num_data){
  pairs(num_data, col = "dodgerblue")

}

# function to get vif of a model 
get_vif = function(model){
  vif(model)
}

# function to get pair-wise correlations for dataframe with numerical columns only 
get_cor = function(num_data){
  cor(num_data)
}

# ========================================================================================================================================= #

## 2. FUNCTIONS FOR CHECKING LINEAR REGRESSION MODEL ASSUMPTIONS (LINE) ##

# function to plot fitted vs. residula plot to test homoscedasticity - uniform variation in error plotted against the fitted value or response  
plot_fitted_resid = function(model, pointcol = "dodgerblue", linecol = "darkorange") {
  plot(fitted(model), resid(model), col = pointcol, pch = 20, cex = 1.5, xlab = "Fitted", ylab = "Residuals")
  abline(h = 0, col = linecol, lwd = 2)
}

# function to get decision of Breusch-Pagan Test (for checking homoscedasticity)
get_bp_decision = function(model, alpha) {
  decide = unname(bptest(model)$p.value < alpha)
  ifelse(decide, "Reject", "Fail to Reject")
}

# function to plot qq-plot & qq-line
plot_qq = function(model, pointcol = "dodgerblue", linecol = "darkorange") {
  qqnorm(resid(model), col = pointcol, pch = 20, cex = 1.5)
  qqline(resid(model), col = linecol, lwd = 2)
}

# function to get decision of Shapiro-Wilk Test (for normality of error term)  
get_sw_decision = function(model, alpha) {
  decide = unname(shapiro.test(resid(model))$p.value < alpha)
  ifelse(decide, "Reject", "Fail to Reject")
}

# Linear Regression Diagnostic function to check 'homoscedasticity of residuals' and 'normalty of residuals w. response'
>>>>>>> Stashed changes
diagnostics = function(model,
                      pcol = "grey",
                      lcol = "dodgerblue",
                      alpha = 0.05,
                      plotit = "TRUE",
                      testit = "TRUE"){
  
  if(plotit){
    par(mfrow = c(1, 2))
<<<<<<< Updated upstream
    
=======
>>>>>>> Stashed changes
    plot(fitted(model), resid(model), col = pcol, pch = 20, xlab = "Fitted", ylab = "Residuals", main = "Residuals vs. Fitted")
    abline(h = 0, col = lcol, lwd = 2)
    
    qqnorm(resid(model), main = "Normal Q-Q Plot", col = pcol)
    qqline(resid(model), col = lcol, lwd = 2)
  }
  
  if(testit){
    p_val = shapiro.test(resid(model))$p.value
    decision = ifelse(shapiro.test(resid(model))$p.value <= alpha, "Reject", "Fail to Reject")
    list(p_val = p_val, decision = decision)
  }
}

<<<<<<< Updated upstream
diagnostics(mod_fix, testit = FALSE)
```


```{r}
mod_aic = step(mod, direction = "forward")
summary(mod_aic)
=======

>>>>>>> Stashed changes

```


<<<<<<< Updated upstream
```{r}

cah_tst_data$ocean_proximity = as.factor(cah_tst_data$ocean_proximity)
cah_tst_data$pop_per_hh = cah_tst_data$population / cah_tst_data$households
cah_tst_data$rooms_per_hh = cah_tst_data$total_rooms / cah_tst_data$households
cah_tst_data$bedrooms_per_hh = cah_tst_data$total_bedrooms / cah_tst_data$households


y_hat_tst = predict(mod, newdata = cah_tst_data ) 
sqrt(mean((y_hat_tst - cah_tst_data$median_house_value)^2, na.rm = TRUE))

```

=======
## EDA
## Data cleaning
## Variable Creation
## Model Building
>>>>>>> Stashed changes
## Model Selection
## Graphs and Tables  
## QA: How do we know what we did makes sense?.
## Move to final report